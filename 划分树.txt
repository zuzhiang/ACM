http://www.cnblogs.com/pony1993/archive/2012/07/17/2594544.html

作用：解决区间内的第K大值问题。

构建过程：第一步建树，第二步查询。


建树：

第一步：找到序列的中位数，把大于中位数的扔到中位数的左边，小于中位数的扔到数的右边。这样整个序列就被分成了两个区间。

第二步：对每个子区间，也分别执行第一步操作，直到序列中只有一个元素为止。


注意：

第一：建树是分层的，所以代码中用的是二维数组tree[20][M]。一般10W级别的数据，20层已经够了。

第二：建树划分的标准是中位数，所以需要排序。而且只排一次序就OK了，因为对于任意序列： 划分后，左边的数据永远不会大于右边的数据。那么对左边数据单独排序与整体排序的结果是一样的，所以排一次序就OK了！

第三：划分树划分好的数据永远在存放在下一层。

第四：划分到最后，实际上已经对序列进行排序了。

第五：划分的过程，需要把每层的数据记录toLeft[i][j]定义为：第i层[1,j]之间有多个数据被分到了左边（注意这里用的是闭区间）。


