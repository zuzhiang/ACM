尼姆博弈
有n堆若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

也可以表述为：每次选择一堆数量为k的石子，可以把它变成0、变成1、……、变成k-1，但绝对不能保持k不变。


//例题：POJ2234
#include <cstdio>
using namespace std;
int main(){
    int m,ans,n;
    while(~scanf("%d",&m)){
        n=ans=0;
        while(m--)
            scanf("%d",&n),ans^=n,printf("ans=%d\n",ans);
        if(ans)printf("Yes\n");
        else printf("No\n");
    }
}


hud 1907 John
这道题有些不一样，如果John吃的是某个盒子最后一颗，那就判定John为败。
所以，这道题分为两种情况讨论：
①若所有堆的数量都为1。则根据奇偶来判断谁胜。
②其他情况，将所有数据异或起来，判断是否为奇异态。



其中，如果要算当前状态先手必胜的方式有几种的话;经典算法中，f=a[0]^a[1]^……^a[n]，若为0，则先手必败，否则必胜。在必胜态时，先手要做的就是拿走某堆石头中的m个，使得f变为0，将必败态转嫁给后手，题目就是在问有几种使XOR变为0的方法。

当(f^a[i])<a[i]的时候方式便加一。其中f=a[0]^a[1]^……^a[n] ，注意或运算的优先级较低，要加括号。

PS: b^a^a=b