欧几里德算法又称辗转相除法，用于计算两个整数a,b的最大公约数。扩展欧几里德算法是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b)（解一定存在，根据数论中的相关定理）。

扩展算法：
对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。


扩展欧几里德算法的应用主要有以下三方面：
（1）求解不定方程；
（2）求解模线性方程（线性同余方程）；
（3）求解模的逆元；



x,y的通解：
假设d=gcd(a,b). 那么x=x0+b/d*t; y=y0-a/d*t;其中t为任意常整数,x0,y0为特解。

推导过程：
ax+by=gcd(a,b),设x0,y0为一组特解，则有

ax0+by0=gcd(a,b),两式相减，得

a(x-x0)+b(y-y0)=0,即 a(x-x0)=b(y0-y)

若a,b互质，则x-x0和b一定有倍数关系，y0-y和a一定有倍数关系，但a,b不互质

则等式两边同除gcd(a,b), a/gcd(a,b) 和 b/gcd(a, b) 一定互质。

则x-x0=t*b/gcd(a,b),即x=x0+t*b/gcd(a,b) ；y0-y=t*a/gcd(a,b),即y=y0+t*a/gcd(a,b) 即x和y的通解，其中t为任意常数


求解 x，y的方法的理解

设 a>b。

1，显然当 b=0，gcd（a，b）=a。此时 x=1，y=0；

2，a>b>0 时

设 ax1+ by1= gcd(a,b);

bx2+ (a mod b)y2= gcd(b,a mod b);

根据朴素的欧几里德原理有 gcd(a,b) = gcd(b,a mod b);     //辗转相除法

则:ax1+ by1= bx2+ (a mod b)y2;

即:ax1+ by1= bx2+ (a - [a / b] * b)y2=ay2+ bx2- [a / b] * by2;

也就是ax1+ by1 == ay2+ b(x2- [a / b] *y2);

根据恒等定理得：x1=y2; y1=x2- [a / b] *y2;

这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.

上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。

C++实现代码：
传参时x,y的值初始化为0；
int exGcd(int a,int b,int &x,int &y)
{
    int r,t;
    if(b==0)
    {
        x=1;y=0;
        return a;
    }
    r=exGcd(b,a%b,x,y);
    t=x;
    x=y;
    y=t-a/b*y;
    return r;
}

关于扩展欧几里德:
首先扩展欧几里德主要是用来与求解线性方程相关的问题，所以我们从一个线性方程开始分析。现在假设这个线性方程为a*x+b*y=m，如果这个线性方程有解，那么一定有gcd(a,b) | m，即a，b的最大公约数能够整除m  (m%gcd(a,b)==0)。证明很简单，由于a%gcd(a,b)==b%gcd(a,b)==0，所以a*x+b*y肯定能够整除gcd(a,b)，如果线性方程成立，那么就可以用m代替a*x+b*y，从而得到上面的结论，利用上面的结论就可以用来判断一个线性方程是否有解。