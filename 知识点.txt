1.
string str;
输入：cin>>str;  或getline(cin,str);
前者不可以存放带有空格的字符串，后者可以。

2.
123
456
789 
输入如上，每一行的三个数是连续的，要想分开存入矩阵中，读入用scanf(“%1d”, &num);

3.
用string定义变量需要添加#include<string>头文件

4.
定义无穷大：
const int inf=0x3f3f3f3f;

5.
子序列和子串的概念是不一样的，子串是必须连续的，而子序列则可以不连续

6.
从（0,0）点出发的直线到（x，y）点不经过其他点，也就是说x和y互素

7.
printf(“%*s”,10,s);等于printf("%10s",s);
 printf("%*s", len, str),printf 额外接受一个参数作为域宽。如果 str 的长度小于 len ，会用空格使长度补足。

8.
gcd(x, n) = i的充要条件是gcd(x/i, n/i) = 1

9.
若a%m=x  则-a%m=-x

10.
设p是素数且p|ab, 则必有p|a 或者p|b

11.
对于任意的正整数n，存在至少n个连续的正合数（非质数）

12.
double log (double x); 以e为底的对数   
double log2 (double x)
double log10 (double x); 
double exp (double x); 求e的x方

13.
正整数2a-1,2b-1是互素的，当且仅当a,b是互素的

14.
若m是素数，则m有φ(m)个原根，其中φ(m)是欧拉函数。设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。

15.
若x+y=p，其中p为素数，则x、y互素

16.
若x+y=a,lcm(x,y)=b,则gcd(a,b)=gcd(x,y)。即gcd(x+y,lcm(x,y))=gcd(x,y)

17.
任何正整数可以表示为若干个不连续的Fibonacci数之和。

18.
从一个m*n的棋盘的左下角走到右上角，每次只能往右走或者往上走，总的方案数是C(m+n,m)或者C(m+n,n),此时是从点走到点，若从一个格内走到另一个格内，答案是:C(m+n-2,m-1)或者C(m+n-2,n-1)

19.
(a+b)%p=(a%p+b%p)%p    (a-b)%p=(a%p-b%p)%p

a*b%p=(a%p*b%p)%p      (a/b)%p=(a%p*(1/b)%p)%p=(a%p*b^(-1)%p)%p  其中b^(-1)为b的乘法逆元

20.
坐标整数点连接成的正多边形只可能是正方形。

21.
“与”、“或”等运算优先级较低，记得要加括号

22.
对于组合数C(n,m)来说，如果 n & m == m 则C(n,m)为奇数

23.
对于直线 y=a/b x 来说，横纵坐标都为整数的点（包括两端点）有 gcd(a,b)+1 个

24.
二维平面内，对长和宽分别为a、b的矩形，对角线穿过的正方形数为a+b-gcd(a,b)，即横坐标为整数的+纵坐标为整数的-横纵坐标都为整数的。拓展到三维坐标为 a+b+c-gcd(a,b)-gcd(b,c)-gcd(a,c)+gcd(a,b,c)

25.
999…999，共n个9的数乘以比它小的任意数数位和都为9*n

26.
一个DAG需要增加最少的边使其成为一个强连通分量，则边数为max(入度为0的强连通分量数，出度为0的强连通分量数)

27.
相临的两个数互质，如果n为奇数，则n与n-2互质。

28.
C++添加以下语句解决爆栈:
#pragma comment(linker,"/STACK: 1024000000,1024000000")

29.
string.h头文件中的 strrev(s) 可以将 char数组反转

30.
两个常用常数的求法：
double PI=atan(1)*4;
double e=exp(1);

31.
将 ios::sync_with_stdio(false); 加到main函数第一行可以解决C++用cin输入慢的问题

32.
当a、b互素时，方程 ax + by = c 有非负数解的条件为 c > a*b-a-b.

33.
strstr(s,t)函数返回值是char型数组，返回 s 中包含 t 的后缀

34.
杨辉三角的第 2^n - 1 行全是奇数

35.
两向量 a(x1,y1)、b(x2,y2) 共线则：x1*y2 = x2*y1，垂直则: x1*x2+y1*y2 = 0

36.
树上两点之间的最短距离为：两点到根节点的最短距离之和 - 两点最近公共祖先到根节点的距离 * 2

37.
大数 * double型的浮点数会产生精度问题，可以通过模拟乘法运算解决。

38.
对数组 a 进行离散化处理：
排序后用unique函数去重，扫描一遍，如果相邻两数的差>1，则在数组后插入一个值在它们中间的数，重新排序后，可以用二分查找lower_bound函数查找某个值的位置。

39.
二分套二分用来解决两个数组元素两两乘积的第 K 大值。外层二分求C数组中的值 mid，内层二分求C数组中 >mid 的数的个数，可以通过一遍遍历 A数组，然后求B数组中满足条件的个数。
